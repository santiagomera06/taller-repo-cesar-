'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _encode = require('./encode');

var _encode2 = _interopRequireDefault(_encode);

var _decode = require('./decode');

var _decode2 = _interopRequireDefault(_decode);

var _selection = require('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var USE_EXTEND = typeof window.getSelection().extend === 'function';

/**
 * Choice is a module for unobtrusively saving and restoring selections
 * in a contenteditable element.
 */

var Choice = (function () {
  /*
   * @param {Element} rootElem
   * @param {Function} getChildren
   */

  function Choice(rootElem) {
    var getChildren = arguments.length <= 1 || arguments[1] === undefined ? function () {
      return (0, _utils2['default'])(rootElem.childNodes);
    } : arguments[1];
    return (function () {
      _classCallCheck(this, Choice);

      // Because of some Firefox bugs.
      if (!rootElem.contentEditable) {
        throw TypeError('Choice requires a contentEditable element.');
      }

      this.elem = rootElem;
      this._getChildren = getChildren;
    }).apply(this, arguments);
  }

  // Provide the Selection constructor.

  /**
   * getSelection() returns an instance of Choice.Selection with
   * information about the start and end points of the selection.
   *
   * @return {Choice.Selection}
   */

  _createClass(Choice, [{
    key: 'getSelection',
    value: function getSelection() {
      var sel = window.getSelection();
      if (!sel.rangeCount || document.activeElement !== this.elem) {
        return null;
      }

      var children = this._getChildren();
      var start = (0, _encode2['default'])(children, sel.anchorNode, sel.anchorOffset);
      var end = null;

      if (sel.isCollapsed) {
        end = start;
      } else if (start) {
        end = (0, _encode2['default'])(children, sel.focusNode, sel.focusOffset);
      }

      return start && end ? new _selection2['default'](start, end) : null;
    }

    /**
     * restore(selection) restores a selection from an instance of
     * Choice.Selection.
     *
     * @param {Choice.Selection} selection
     */
  }, {
    key: 'restore',
    value: function restore(selection) {
      var sel = window.getSelection();

      if (!(selection instanceof _selection2['default'])) {
        throw TypeError(selection + ' is not a valid selection.');
      }

      var children = this._getChildren();
      var start = undefined,
          end = undefined;

      if (selection.isCollapsed) {
        start = (0, _decode2['default'])(children[selection.end[0]], selection.end[1]);
      } else {
        start = (0, _decode2['default'])(children[selection.start[0]], selection.start[1]);
        end = (0, _decode2['default'])(children[selection.end[0]], selection.end[1]);
      }

      this.elem.focus();

      var range = document.createRange();
      if (USE_EXTEND) {
        range.setStart(start.node, start.offset);
        range.setEnd(start.node, start.offset);

        sel.removeAllRanges();
        sel.addRange(range);

        if (end) {
          sel.extend(end.node, end.offset);
        }
      } else {
        end = end || start;
        if (selection.isBackwards) {
          var _ref = [end, start];
          start = _ref[0];
          end = _ref[1];
        }

        range.setStart(start.node, start.offset);
        range.setEnd(end.node, end.offset);
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }
  }]);

  return Choice;
})();

Choice.Selection = _selection2['default'];
Choice.Choice = Choice;

exports['default'] = Choice;
module.exports = exports['default'];
