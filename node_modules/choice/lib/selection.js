/**
 * Selection(start[, end]) holds information about a selection.
 *
 * @param {Array} start
 * @param {Array} end
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Selection = (function () {
  function Selection(start) {
    var end = arguments.length <= 1 || arguments[1] === undefined ? start.slice() : arguments[1];
    return (function () {
      _classCallCheck(this, Selection);

      this.start = start;
      this.end = end;
    }).apply(this, arguments);
  }

  /**
   * Selection.equals(first, second) is a static method similar to the
   * Selection#equals method, but it can be used to determine the equality
   * of two null selections.
   *
   * @param {Selection} first
   * @param {Selection} second
   * @return {Boolean}
   */

  /**
   * absoluteStart is a getter that returns the endpoint that is first
   * in document order.
   *
   * @return {Array}
   */

  _createClass(Selection, [{
    key: "equals",

    /**
     * equals(other) determines if two selections are equivalent.
     *
     * @param {Selection} other
     * @return {Boolean}
     */
    value: function equals(other) {
      return other instanceof Selection && this.start[0] === other.start[0] && this.start[1] === other.start[1] && this.end[0] === other.end[0] && this.end[1] === other.end[1];
    }

    /**
     * clone() returns a Selection identical to that it was called on.
     *
     * @return {Selection}
     */
  }, {
    key: "clone",
    value: function clone() {
      // To allow subclassing.
      var S = this.constructor;
      return new S(this.start.slice(), this.end.slice());
    }
  }, {
    key: "absoluteStart",
    get: function get() {
      return this.isBackwards ? this.end : this.start;
    }

    /**
     * absoluteEnd is a getter that returns the endpoint that is last
     * in document order.
     *
     * @return {Array}
     */
  }, {
    key: "absoluteEnd",
    get: function get() {
      return this.isBackwards ? this.start : this.end;
    }

    /**
     * isCollapsed is a getter that determines if the Selection represents a
     * collapsed selection.
     *
     * @return {Boolean}
     */
  }, {
    key: "isCollapsed",
    get: function get() {
      return this.start[0] === this.end[0] && this.start[1] === this.end[1];
    }

    /**
     * isBackwards is a getter that determines if the Selection represents a
     * backwards selection.
     *
     * @return {Boolean}
     */
  }, {
    key: "isBackwards",
    get: function get() {
      return this.start[0] > this.end[0] || this.start[0] === this.end[0] && this.start[1] > this.end[1];
    }
  }]);

  return Selection;
})();

Selection.equals = function (first, second) {
  if (!first || !second) {
    return first === null && second === null;
  }

  return first instanceof Selection && first.equals(second);
};

exports["default"] = Selection;
module.exports = exports["default"];
